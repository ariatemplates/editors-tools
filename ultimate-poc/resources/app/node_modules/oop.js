var prelude = require('prelude-ls');

var dop = require('./dop');
var helpers = require('./helpers');



/*******************************************************************************
* Class
*******************************************************************************/

var schemaPropertyNames = ['schema', 'input'];

function klass(input) {

	////////////////////////////////////////////////////////////////////////////
	// Input
	////////////////////////////////////////////////////////////////////////////

	// WARNING 'constructor' always resolves to a non-null value by default, since it's set in the prototype of every JS object. So, since we still want to be able to use own properties and prorotypes properties in spec objects, we need to take care of these special cases. Her we just lookup for this name in the end. Therefore, if you hadn't set explicitely a constructor, the constructor for a raw object whould be found.

	var spec = dop.processProperties(input, {
		properties: [
			{names: schemaPropertyNames},
			{names: ['init', 'ctor', 'initialize', 'initialization', 'build', 'constructor']/*, default: function() {return function() {}}*/},
			{names: ['prototype', 'proto'], default: {}},

			{names: ['methods'], default: {}},
			{names: ['properties', 'props', 'attributes', 'attrs'], default: []},
			{names: ['statics'], default: {}},

			{names: ['callback', 'call']},

			{names: ['parent', 'extend', 'extends', 'superclass', 'superClass', 'super', 'ancestor', 'base']},

			{names: ['id', 'identifiant', 'key']},
			{names: ['name', 'fullname', 'fullName']},
			{names: ['displayName', 'displayname', 'display', 'debugName']},
			{names: ['description', 'desc', 'comment', 'doc', 'documentation']},

			{names: ['factories'], default: {}}
		]
	});



	////////////////////////////////////////////////////////////////////////////
	// Constructor generation
	////////////////////////////////////////////////////////////////////////////

	// TODO Maybe use native utilities to define prototype explicitely, for the case of the optional new operator

	// Input schema ------------------------------------------------------------

	var schema = spec.schema;

	if (schema != null && !prelude.isType('Object', schema)) {
		throw {
			msg: 'Wrong parameter type',
			names: schemaPropertyNames,
			expected: 'Object',
			spec: spec,
			input: input
		}
	}

	// Constructor/init --------------------------------------------------------

	var init = spec.init;

	if (prelude.isType('Object', init)) {
		schema = init;
		init = null;
	}

	if (!prelude.isType('Function', init)) {
		init = function() {};
	}

	// Callable instance -------------------------------------------------------

	var callback = spec.callback;
	var callbackName;

	if (prelude.isType('Object', callback)) {
		callbackName = dop.extractValue(callback, ['alias', 'method', 'name', 'prototype']);
		callback = dop.extractValue(callback, ['def', 'definition', 'fn', 'callback', 'handler', 'exec', 'execute']);
	} else if (!prelude.isType('Function', callback)) {
		// Warning
	}

	if (callback != null) {
		// constructor.prototype = new Function;
		constructor.prototype = Object.create(new Function);
	}

	// Instance properties -----------------------------------------------------

	var properties = helpers.mapArrayFactory(spec.properties, 'descriptor');

	// Generation --------------------------------------------------------------

	// Allows calling the constructor both with and without the `new` keyword
	function constructor$() {};
	constructor$.prototype = constructor.prototype;
	function constructor() {
		// Self ----------------------------------------------------------------
		// Optional "new" & callable instance

		var self;
		// FIXME Keep Function in the prototype chain (with temp function...)
		if (callback != null) {
			self = function() {
				return callback.apply(self, arguments);
			}
			self.__proto__ = constructor.prototype;
		} else if (this instanceof constructor) {
			self = this;
		} else {
			self = new constructor$;
		}

		// Applies actual initialization ---------------------------------------

		var args = Array.prototype.slice.call(arguments);

		if (schema != null) {
			try {
				dop.processProperties(self, args[0], schema, self);
			} catch (exception) {
				exception.class = constructor.displayName;
				throw exception;
			}
			args.shift();
		}

		init.apply(self, args);

		// Defines instance properties -----------------------------------------

		// --------------------------------------------------------- Simple form

		prelude.each(function(property) {
			prelude.each(function(name) {
				Object.defineProperty(self, name, property.descriptor);
			}, property.names);
		}, properties);

		// ---------------------------------------------------- "Optimized" form

		// for (var propertiesIndex = 0, propertiesLength = properties.length; propertiesIndex < propertiesLength; propertiesIndex++)  {
		// 	var property = properties[propertiesIndex];
		// 	var names = property.names;
		// 	for (var namesIndex = 0, namesLength = names.length; namesIndex < namesLength; namesIndex++)  {
		// 		Object.defineProperty(self, names[namesIndex], property.descriptor);
		// 	}
		// }

		// Return --------------------------------------------------------------

		return self;
	}



	////////////////////////////////////////////////////////////////////////////
	// Inheritance, Prototype & statics
	////////////////////////////////////////////////////////////////////////////

	var statics = spec.statics;
	var prototype = spec.prototype;

	// Inheritance -------------------------------------------------------------

	inherit(constructor, spec.parent);

	// Prototype & Methods -----------------------------------------------------

	var methods = spec.methods;

	for (var methodName in methods) {
		prototype[methodName] = methodFactory(methods[methodName]);
	}

	if (callbackName != null) {
		prototype[callbackName] = callback;
	}

	// Identification ----------------------------------------------------------

	helpers.import(statics, buildIdentification(spec));
	statics.description = spec.description;

	// Automatic special factory generation ------------------------------------

	statics.factory = function factory(input) {
		if (input == null) {return undefined;}
		if (input instanceof constructor) {return input;}
		return new constructor(input);
	};

	// Application & return ----------------------------------------------------

	helpers.import(constructor.prototype, prototype);
	addStatics(constructor, statics);
	addFactories(constructor, spec.factories);

	return constructor;
}

/**
 * Adds static properties to a class, that is properties assigned to the constructor.
 *
 * @fixme Aren't statics related to prototype instead?? Check the naming.
 */
function addStatics(constructor, statics) {
	helpers.import(constructor, statics);
}

/**
 * Composite method to generate multiple factories from the given spec and add them to the given constructor.
 */
function addFactories(constructor, factoriesSpecs) {
	if (factoriesSpecs != null) {
		for (var factoryName in factoriesSpecs) {
			addFactory(constructor, factoryName, factoriesSpecs[factoryName]);
		}
	}
}

/**
 * Just processes value inference between properties `id`, `name` and `displayName`.
 */
function buildIdentification(spec) {
	var id = spec.id;
	var name = spec.name;
	var displayName = spec.displayName;

	id == null && (id = name);
	id == null && (id = displayName);

	name == null && (name = id);
	name == null && (name = displayName);

	displayName == null && (displayName = id);
	displayName == null && (displayName = name);

	return {
		id: id,
		name: name,
		displayName: displayName
	}
}

/**
 * Applies inheritance for the given constructor and parent constructor.
 *
 * Inheritance means extending (see `extend`), and importing all properties of the parent constructor to the new constructor.
 */
function inherit(constructor, parent) {
	if (parent != null) {
		helpers.import(constructor, parent);
		extend(constructor, parent);
	}
}

/**
 * Extends a constructor from a parent constructor.
 *
 * Extending means setting up the prototype chain: the prototype of the constructor is an object whose prototype itself is the one of the parent.
 *
 * It also sets some properties to access parent features, like:
 * - a link to the parent constructor: `superclass`
 */
function extend(constructor, parent) {
	constructor.superclass = parent;

	constructor.prototype = Object.create(parent.prototype, {
		constructor: {
			value: constructor,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});

	return constructor;
}


/**
 * @todo Maybe put properties on the generated function, this way its behavior could be changed at runtime.
 */
function methodFactory(input) {
	if (prelude.isType('Function', input)) {
		return input;
	}

	dop.processProperties(method, input, {
		properties: [
			{names: ['input', 'in', 'arg', 'argument', 'schema', 'spec']},
			{names: ['process', 'exec', 'execute', 'run', 'fn', 'handler']},
			{names: ['chainable', 'chain']},
			{names: ['output', 'out', 'return', 'returns']}
		]
	}, null);

	function method(input) {
		var result;

		if (method.input != null) {
			var spec = dop.processProperties(null, input, method.input, this);
			result = method.process.call(this, spec);
		} else {
			result = method.process.apply(this, arguments);
		}

		// Returns -------------------------------------------------------------

		if (method.chainable) {return this;}
		if (method.input != null && method.output != null) {return spec[method.output];}
		return result;
	}

	return method;
}



/*******************************************************************************
* Class factories
*******************************************************************************/

/**
 * Creates a factory using the given spec and adds it to the given constructor under the given name.
 */
function addFactory(constructor, name, spec) {
	constructor[name] = createFactory(constructor, spec);
}

function createFactory(constructor, spec) {
	var argsMap = dop.extractProperty(spec, {names: ['args', 'arguments'], default: {}});
	var valuesMap = dop.extractProperty(spec, {names: ['values', 'vals'], default: {}});

	return function() {
		var spec = {};

		for (var specProperty in argsMap) {
			spec[specProperty] = arguments[argsMap[specProperty]];
		}

		for (var specProperty in valuesMap) {
			spec[specProperty] = valuesMap[specProperty];
		}

		return new constructor(spec);
	}
}




/*******************************************************************************
* Predefined types
*******************************************************************************/

var types = {
	String: {factory: function(input) {return "" + input;}},
	Boolean: {factory: function(input) {return Boolean(input);}},
	Number: {
		factory: function(input) {
			var value = Number(input);
			if (isNaN(value)) return undefined;
			return value;
		}
	},
	Array: {
		factory: function(input) {
			if (!prelude.isType('Array', input)) {
				return [input];
			}

			return input;
		}
	},
	Function: {
		factory: function(input) {
			if (!prelude.isType('Function', input)) {
				return undefined;
			}

			return input;
		}
	}
}





/*******************************************************************************
* Export
*******************************************************************************/

exports.class = klass;
exports.Class = klass;

exports.inherit = inherit;
exports.extend = extend;

exports.addStatics = addStatics;

exports.addFactory = addFactory;
exports.createFactory = createFactory;

exports.methodFactory = methodFactory;



exports.types = types;
