var prelude = require('prelude-ls');

var oop = require('oop').oop;

var Parser = require('./pegjs-parser/parser').Parser;



// TODO Split the input definition in more models: one for location. Btw 'Location' should be made standard.
// Here location properties could be mixed with other properties

// TODO The input definition of a graph is not the same: it takes no text, since it considers the source property is already up to date. So just take the input specification of the other methods, just without the text. That is: combine specifications.

/*******************************************************************************
 * Specifications: schemas, properties, ...
 ******************************************************************************/

var sourcePropertyNames = ['text', 'txt', 'source', 'src', 'content', 'string', 'str'];

var updateInputSpec = {
	inputToSpec: {
		'String': function(input) {
			return {
				text: input,
				replace: true
			}
		}
		// Makes no sense for now...
		//,
		// 'Number': 'start'
	},
	properties: [
		{
			names: sourcePropertyNames,
			desc: 'The new text to set.',
			default: '',
			type: oop.types.String
		},
		{
			names: ['start', 'beginning', 'offset', 'index'],
			desc: 'INCLUSIVE, 0-based. The start index relative to the current code from which the given text will be set.',
			default: function() {return this.source.length;}, // appended text by default
			type: oop.types.Number
		},
		{
			names: ['end', 'stop'],
			desc: 'EXCLUSIVE, 0-based. The end index relative to the current code until which the given text will be set.',
			// inferred: 'start'
			type: oop.types.Number
		},
		{
			names: ['replace', 'erase', 'swap'],
			desc: 'A flag to ignore offsets and replace the entire current text with the given one.',
			default: false,
			type: oop.types.Boolean
		},
	]
};




/*******************************************************************************
 * Class: Code
 ******************************************************************************/

var Code = oop.class({
	name: 'Code',

	desc: 'Model for a source code. Kind of equivalent (but more specific) to the Document model in Eclipse.',

	// schema: {
	// 	properties: [
	// 		{names: ['parser'], type: Parser, required: true},
	// 		{names: ['input']}
	// 	]
	// },

	constructor: function(parser, input) {
		this.parser = parser;

		this._source = '';
		this._graph = undefined;

		if (input != null) {
			this.update(input);
		}
	},

	properties: [
		{
			names: sourcePropertyNames,
			desc: {
				get: function() {
					return this._source;
				},
				set: function(input) {
					this.updateSource(input);
				}
			}
		},
		{
			names: ['graph', 'tree', 'ast', 'nodes', 'node'],
			desc: {
				get: function() {
					return this._graph;
				}
			}
		}
	],

	methods: {
		/**
		 * WARNING: Be careful of being efficient in this method, it is critical as this is the one called the most often!
		 *
		 * @todo? be able to specify a length property (computing end or start)
		 * @todo? be able to specify a unique end property for insertion (like it does for now with unique start)
		 * @todo be able to specify a pos property, for insertion, less confusing that the unique start or end property
		 */
		update: {
			desc: 'Updates the models of the code given a diff description in the source code.',
			input: updateInputSpec,

			process: function(spec) {
				// "Hack" for optimization: only calls the "actual" function without processing the input again.
				// Wait for the library to give a feature to do it more cleanly
				this.updateSource.process.call(this, spec);
				// this.updateGraph.process.call(this, spec);
				try {
					this._graph = this.parser.parse(this.source);

					graph.shared.dirty = graph.id;

					return {
						state: 'uptodate',
						dirty: graph.id
					}
				} catch (exception) {
					return {
						state: 'pending',
						exception: exception
					}
				}
			}
		},

		updateSource: {
			desc: 'Updates the source.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._source = spec.text;
				} else {
					if (spec.end == null) {
						spec.end = spec.start;
					}

					this._source =
						this.source.substring(0, spec.start) +
						spec.text +
						this.source.substring(spec.end, this.source.length);
				}
			}
		},

		updateGraph: {
			desc: 'Updates the graph.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._graph = this.parser.parse(this.source);
				} else {
					this._graph = this.parser.parse(this.source);
				}
			}
		}
	}
})



exports.Code = Code;
