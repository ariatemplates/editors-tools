var prelude = require('prelude-ls');

var oop = require('./oop');
var helpers = require('./helpers');



/*******************************************************************************
* Property names
*******************************************************************************/

var propertyIds = {
	names: ['names', 'name', 'keys', 'key', 'ids', 'id']
}


// var map = [
// 	{name: 'output', default: {}},
// 	{name: 'input'},
// 	{name: 'rules'}
// ]

// function processArguments(args, rules) {
// 	var output = {};
// 	for (var argPos = 0, length = rules.length; i < length; i++) {
// 		var arg = args[argPos];
// 		var def = rules[argPos].default;
// 		if (arg == null && def != null) {
// 			arg = def;
// 			args.
// 		}
// 	}
// }


function processProperties() {
	var output;
	var input;
	var rules;
	var context;

	if (arguments.length === 4) {
		output = arguments[0];
		input = arguments[1];
		rules = arguments[2];
		context = arguments[3];
	} else if (arguments.length === 3) {
		throw {
			msg: 'Ambiguous arguments',
			arguments: arguments,
			stack: Error().stack
		}
	} else if (arguments.length === 2) {
		input = arguments[0];
		rules = arguments[1];
	} else {
		throw {
			msg: 'Wrong number of arguments',
			arguments: arguments,
			stack: Error().stack
		}
	}

	if (output == null) {output = {};}

	// if (arguments.length < 3) {
	// 	output = {};
	// 	input = arguments[0];
	// 	rules = arguments[1];
	// } else {
	// 	output = arguments[0];
	// 	input = arguments[1];
	// 	rules = arguments[2];
	// }

	var spec = inputToSpec(input, extractValue(rules, ['inputToSpec', 'inputFactory', 'factory']));
	applyProperties(output, spec, extractValue(rules, ['properties', 'props', 'schema', 'specs', 'spec']), context, extractValue(rules, ['acceptFreeProperties', 'acceptFree', 'free', 'extensible']));

	return output;
}

function inputToSpec(input, rules) {
	if (prelude.isType('Object', input)) {
		return input;
	}

	rules == null && (rules = {});
	for (var type in rules) {
		if (prelude.isType(type, input)) {
			var ruleValue = rules[type];

			var handler;
			if (prelude.isType('String', ruleValue)) {
				handler = function(input) {
					var output = {};
					output[ruleValue] = input;
					return output;
				}
			} else if (prelude.isType('Function', ruleValue)) {
				handler = ruleValue;
			} else {
				handler = function() {return {}};
			}

			return handler(input);
		}
	}

	return {};
}

/**
 * Extracts a set of properties from a spec object, thanks to properties specifications, and puts the result in the output object.
 *
 * @see extractProperty
 */
function applyProperties(output, spec, propertiesSpecs, context, acceptFree) {
	var infosList = [];
	for (var key in propertiesSpecs) {
		infosList.push(applyProperty(output, spec, propertiesSpecs[key], context).infos);
	}

	if (acceptFree) {
		// Builds a list of used properties
		var usedNames = [];
		for (var i = 0, length = infosList.length; i < length; i++) {
			var infos = infosList[i];
			usedNames.push(infos.name);
		}

		// Imports free properties
		for (var specKey in spec) {
			if (spec.hasOwnProperty(specKey) && usedNames.indexOf(specKey) < 0) {
				output[specKey] = spec[specKey];
			}
		}
	}

	return output;
}

function propertySpecFactory(propertySpec) {
	if (prelude.isType('String', propertySpec)) {
		return {names: [propertySpec]};
	}

	if (prelude.isType('Array', propertySpec)) {
		return {names: propertySpec};
	}

	return propertySpec;
}

/**
 * @todo For now we consider we don't put any explicit undefined or null value in the output. This could be made configurable
 */
function applyProperty(output, spec, propertySpec, context) {
	propertySpec = propertySpecFactory(propertySpec);

	var infos = {};

	var value = extractProperty(spec, propertySpec, context, infos);

	if (value != null) {
		// Gets the explicit name for the output property
		var name = extractValue(propertySpec, ['output', 'outputName']);

		// If not explicit name was given, gets the first name of the list of possible property names
		if (name == null) {
			name = oop.types.Array.factory(extractValue(propertySpec, propertyIds.names))[0];
		}

		if (name != null) {
			output[name] = value;
		} else {
			throw {
				msg: 'No name found for the output property',
				spec: propertySpec,
				value: value,
				output: output
			}
		}
	}

	return {
		infos: infos,
		value: value,
		output: output
	}
}

function extractProperty(spec, propertySpec, context, infos) {
	// An object that will be useless since not returned but will avoid multiple checks below
	if (infos == null) {
		infos = {};
	}

	// propertySpec ------------------------------------------------------------

	propertySpec = propertySpecFactory(propertySpec);

	// Extraction --------------------------------------------------------------

	var value = extractValue(spec, extractValue(propertySpec, propertyIds.names), infos);
	infos.originalValue = value;

	// Null - Skips the property -----------------------------------------------
	// Explicit null value will skip the process of inference, applying default value, ...

	if (value === null) {
		infos.skipped = true;
		return;
	};
	infos.skipped = false;

	// Constructor -------------------------------------------------------------

	// WARNING Same remark as previous in this file: 'constructor' to be kept at the end
	var constructor = extractValue(propertySpec, ['ctor', 'type', 'factory', 'constructor']);

	if (constructor != null) {
		infos.constructor = constructor;

		var factory = constructor.factory;

		if (factory != null) {
			infos.factory = factory;

			if (value !== undefined) {
				value = factory(value);
			}

			if (value == null && propertySpec.mixed) {
				try {
					infos.mixed = true;
					value = factory(spec);
				} catch (e) {}
			}
		} else {
			infos.factory = null;
		}
	}

	// Default -----------------------------------------------------------------

	if (value === undefined) {
		var def = extractValue(propertySpec, ['default', 'def']);
		if (def != null) {
			if (prelude.isType('Function', def)) {
				// TODO be able to specify context per spec
				// def = def(extractValue(spec, ['context', 'scope']);
				def = def.call(context);
			}

			infos.default = true;

			value = def;

			if (factory != null && value !== undefined) {
				value = factory(value);
			}
		}
	}

	// Post-process ------------------------------------------------------------

	var postprocess = extractValue(propertySpec, ['postprocess', 'postProcess', 'post', 'process']);
	if (postprocess != null) {
		infos.postProcessed = true;
		value = postprocess(value);
	} else {
		infos.postProcessed = true;
	}

	// Required ----------------------------------------------------------------

	var required = extractValue(propertySpec, ['required', 'req']);
	if (required) {
		if (value == null) {
			throw {
				msg: 'Missing required value',
				property: propertySpec,
				spec: spec
			}
		}
	}

	// Output ------------------------------------------------------------------

	infos.value = value;
	return value;
}

/**
 * Extracts a value from the given object using the given names
 */
function extractValue(input, names, infos) {
	if (names == null) {
		throw Error('No names given');
	}

	names = oop.types.Array.factory(names);

	for (var i = 0, length = names.length; i < length; i++) {
		var name = names[i];
		var property = input[name];
		if (property !== undefined) {
			if (infos != null) {
				infos.name = name;
				infos.own = input.hasOwnProperty(name);
			}
			return property;
		}
	}
}





exports.processProperties = processProperties;
exports.inputToSpec = inputToSpec;

exports.applyProperties = applyProperties;
exports.applyProperty = applyProperty;

exports.extractProperty = extractProperty;

exports.extractValue = extractValue;

exports.propertyIds = propertyIds;
