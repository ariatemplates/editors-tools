var prelude = require('prelude-ls');
var escapeHTML = require('escape-html');

var oop = require('std/oop');
var dop = require('std/dop');
var stderror = require('std/error');

var STDError = stderror.STDError;
var NotImplemented = stderror.NotImplemented;

var Code = require('./code').Code;
var Parser = require('./pegjs-parser/parser').Parser;
var Stylesheet = require('./highlight/stylesheet').Stylesheet;
var OutlineNode = require('./outline/outline-node').OutlineNode;



function getOptions(input) {
	return dop.extractProperty(input, {names: ["options", "opts"], default: {}});
}


var Mode = oop.Class({
	name: 'Mode',

	schema: {
		properties: [
			{
				names: ['parser'],
				type: Parser,
				required: true
				// validate: function(parser) {
				// 	if typeof parser?parse isnt 'function' => throw {
				// 		msg: 'Invalid given parser'
				// 		parser
				// 	}
				// }
			},
			{names: ['stylesheet', 'style'], output: '_stylesheet', type: Stylesheet},
			{names: ['highlightDefaultStyleNodes'], type: oop.types.Array, default: []},
			{names: ['outlineRules', 'outline']}
		]
	},

	init: function() {
		if (!prelude.isType('Function', this.parser.parse)) {
			throw STDError({
				msg: 'Invalid given parser',
				parser: this.parser
			});
		}

		this.highlightedNodes = this.highlightDefaultStyleNodes.concat(this._stylesheet.stylesNames());
	},



	prototype: {
		/***********************************************************************
		 * Init
		 **********************************************************************/

		/**
		 * Creates a code instance using this mode from the given source.
		 */
		create: function(source) {
			return new Code(this.parser, source);
		},


		/***********************************************************************
		 * Model
		 **********************************************************************/

		/**
		 * Updates the code models.
		 */
		update: function(code, input) {
			code.update(input);
		},



		/***********************************************************************
		 * Parse
		 **********************************************************************/

		/**
		 * Returns an AST.
		 *
		 * Basically it removes circular links from the graph, and also "internal" properties, especially the object shared between all nodes, which doens't make sense since it's not part of the tree.
		 *
		 * WARNING This returns a copy of the graph, because we must not modify it directly!
		 *
		 * FIXME Should use a depth-first traversal function: that way the 'children' propety used for traversal could be altered too
		 */
		parse: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			graph.traverse(function(node) {
				delete node.parent;
				delete node.shared;

				delete node.childrenIndex;

				if (Object.keys(node.flags).length === 0) {
					delete node.flags;
				}
				if (Object.keys(node.properties).length === 0) {
					delete node.properties;
				}
			});

			return graph;
		},



		/***********************************************************************
		 * Highlight
		 *
		 * FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)
		 * XXX Be able to provide a default stylesheet, common for all modes? This would require to have the same token names...
		 **********************************************************************/

		/**
		 * Returns the stylesheet used by this mode.
		 */
		stylesheet: function(code, input) {
			return this._stylesheet;
		},

		css: function() {
			return this._stylesheet.css();
		},

		/**
		 * @todo handle line endings more nicely
		 */
		html: function(code, input) {
			var source = code.source;

			var ranges = this.highlight(code, input).ranges;

			var output = "";
			for (var i = 0, length = ranges.length; i < length; i++) {
				var range = ranges[i];

				var str = escapeHTML(source.substring(range.start, range.end));
				str = str.replace(/\r\n/g, '\n');
				str = str.replace(/\n/g, '<br/>');
				str = str.replace(/ /g, '&nbsp;');
				str = str.replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');

				var style = '';
				if (range.style != '') {
					style = ' editor-highlight-' + range.style;
				}
				output += "<span class='editor-highlight-token" + style + "'>" + str + "</span>";
			}

			return output;
		},

		/**
		 * @todo Add an option to return more information in some ranges, like the ones about line endings
		 */
		highlight: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			// XXX Not even necessary I guess, marks/flags could be left, and this could even be a good thing for performances (always taking care of having up to date marks)
			graph = graph.copy();

			// Marks -----------------------------------------------------------

			var highlightedNodes = this.highlightedNodes;

			graph.traverse(function(node) {
				if (highlightedNodes.indexOf(node.type.element) !== -1) {
					node.highlight = {
						style: node.type.element
					}
				}
			});

			// For development -------------------------------------------------

			// Checks that every branch of the graph has a highlight mark, so that we will end with the whole source code highlighted

			if (false) {
				var branches = graph.branches();
				for (var i = 0, length = branches.length; i < length; i++) {
					var branch = branches[i];
					var branchOK = false;
					for (var j = 0, length2 = branch.length; j < length2; j++) {
						var fragment = branch[j];
						if (fragment.highlight != null) {
							branchOK = true;
							break;
						}
					}
					if (!branchOK) {
						throw {
							msg: 'A branch is not marked for highlighting',
							number: i + 1,
							branch: prelude.map(function(node) {
								return {
									src: node.source,
									type: node.type.element
								}
							}, branch)
						}
					}
				}
			}

			// Sinks -----------------------------------------------------------

			// Gets marks from parents and put them into their children, to have all leaves marked, even if their marks have style corresponding to some ancestor nodes' types.

			graph.traverse(function(node) {
				if (node.highlight != null) {
					for (var i = 0, length = node.children.length; i < length; i++) {
						var child = node.children[i];
						if (child.highlight == null) {
							child.highlight = node.highlight;
						}
					}
				}
			});

			// Transforms ------------------------------------------------------

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end.index,
					style: token.highlight != null ? token.highlight.style : ''
				};
			}, graph.leaves);

			// Collapses -------------------------------------------------------

			// Collapses consecutive ranges that have the same style

			var finalRanges = [];
			var lastStyle;
			while (ranges.length > 0) {
				var range = ranges.shift();
				if (range.style === lastStyle) {
					finalRanges[finalRanges.length - 1].end = range.end;
				} else {
					finalRanges.push(range);
					lastStyle = range.style;
				}
			}

			// Returns ---------------------------------------------------------

			return {
				ranges: finalRanges
				// lineFeedType: ''
			};
		},

		/***********************************************************************
		 * Outline
		 **********************************************************************/

		/**
		 * @fixme Why in the "specs" do I require a list of elements to be returned, while this will always be a single node (the root)? Or maybe I would like to avoid the root!
		 */
		outline: function(code, input) {
			var type = dop.extractProperty(input, {names: ['type'], default: "full"});

			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var outline;
			if (type === "simpleTree") {
				outline = this._outlineSimpleTree(graph.simpleTree());
			} else if (type === "simple") {
				outline = this._outlineNode(graph);
			} else if (type === "full") {
				outline = this._outline(graph);
			}

			return {
				tree: outline.children
			};
		},

		_outline: function(node) {
			// label -----------------------------------------------------------

			var label = node.key || '<root>';

			// children --------------------------------------------------------

			var children = [];

			// ---------------------------------------------- classic properties

			children.push('type: ' + node.type.element);

			children.push({
				label: 'location',
				children: [
					{
						label: 'start',
						children: [
							'index: ' + node.location.start.index,
							'line: ' + node.location.start.line,
							'column: ' + node.location.start.column
						]
					},
					{
						label: 'end',
						children: [
							'index: ' + node.location.end.index,
							'line: ' + node.location.end.line,
							'column: ' + node.location.end.column
						]
					}
				]
			});

			var indexes = [
				'index: ' + node.index,
				'id: ' + node.id
			];

			if (node._listIndex != null) {
				indexes.push('list index: ' + node._listIndex);
			}

			children.push({
				label: 'indexes',
				children: indexes
			});

			// ----------------------------------------------------------- flags

			var flags = [];
			for (var flag in node.flags) {
				if (node.flags[flag] === true) {
					flags.push(flag);
				}
			}

			children.push({
				label: 'flags',
				children: flags
			});

			// ------------------------------------------------------ properties

			var properties = [];
			for (var property in node.properties) {
				properties.push(property + ' = ' + node.properties[property]);
			};

			children.push({
				label: 'properties',
				children: properties
			});

			// --------------------------------------------------- node children

			var outlinedChildren = [];
			for (var i = 0, length = node.children.length; i < length; i++) {
				outlinedChildren.push(this._outline(node.children[i]));
			}

			children.push({
				label: 'children',
				children: outlinedChildren
			});

			// Result ----------------------------------------------------------

			return OutlineNode({
				label: label,
				children: children
			});
		},

		_outlineNode: function(node) {
			// label -----------------------------------------------------------

			var id = node.key || 'root';
			var type = node.type.element;

			var label = id + ": " + type;

			// children --------------------------------------------------------

			var children = node.children;

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineNode(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},

		_outlineSimpleTree: function(node) {
			// label -----------------------------------------------------------

			var label = Object.keys(node)[0];

			// children --------------------------------------------------------

			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineSimpleTree(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},

		/***********************************************************************
		 * Validate
		 **********************************************************************/

		validate: function() {
			throw NotImplemented;
		},

		/***********************************************************************
		 * Folding
		 **********************************************************************/

		/**
		 * Returns a list of foldable lines ranges.
		 *
		 * A range is a start line and a end line. Only "real" ranges are returned, that is you can be sure that the starts line is different from the end line.
		 *
		 * Foldable ranges are determined by block nodes. Every block is marked as potentially foldable. Then, blocks which don't span multiple lines are unmarked.
		 *
		 * Also, to avoid folding handles collision, blocks that start on the same line are avoided: between two colliding blocks, we want to keep the most enclosing ones. For that, there is a simple rule, strongly based on hypothesis made from the nature of the graph:
		 * - two blocks are likely to start on the same line only if they are contained in the same subtree
		 * - the most enclosing one is the closest to the root
		 */
		fold: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			// Marks & filters -------------------------------------------------

			// Marks block nodes as potentially foldable
			graph.traverse(function(node) {
				if (node.is('block')) {
					if (node.location.start.line != node.location.end.line) {
						node.flag('foldable');
					}
				}
			});

			// Unmarks blocks that begin on the same line of other bigger blocks
			graph.traverse(function(node) {
				if (node.is('foldable') && node.index == 0) {
					var lineRef = node.location.start.line;
					node.traverse(function(descendant) {
						if (descendant !== node && descendant.location.start.line == lineRef) {
							descendant.unflag('foldable');
						}
					});
				}
			});

			// Extracts --------------------------------------------------------

			var blocks = graph.pick('foldable');

			// Transforms ------------------------------------------------------

			var ranges = prelude.map(function(node) {
				return {
					start: node.location.start.line,
					end: node.location.end.line
				}
			}, blocks);

			// Returns ---------------------------------------------------------

			return ranges;
		},

		/***********************************************************************
		 * Graph visualization: for client-side
		 **********************************************************************/

		/**
		 * Returns analysis data about the graph representing the code, plus data to use for visual display of it.
		 */
		graph: function(code, options) {
			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var library = dop.extractProperty(options, {
				names: ['library', 'lib', 'type', 'framework', 'engine', 'system'],
				type: oop.types.String,
				default: "cytoscape"
			});

			var graphDisplay = this._graphBuilder[library](graph);

			return {
				leaves: graph.shared.stats.leaves,
				nodes: graph.shared.stats.nodes,
				graph: graphDisplay
			}
		},

		_graphBuilder: {
			/**
			 * Returns a representation of the graph suitable for the JavaScript InfoVis Toolkit library.
			 *
			 * @unimplemented
			 */
			jit: function(graph) {
				throw "Unimplemented";
			},

			/**
			 * Returns a representation of the graph suitable for the Cytoscape.js library.
			 *
			 * The easiest way of using Cytoscape.js is to explicitely specify separately nodes and their connections, that is edges.
			 *
			 * @return An object containing a list of nodes and a list of edges: {nodes, edges}
			 */
			cytoscape: function(graph) {
				var nodes = [];
				var edges = [];

				graph.traverse(function(node) {
					var nodeId = node.getPosition();

					// Node data -----------------------------------------------
					// A new node to go into the list of nodes

					var nodeData = {id: nodeId};

					nodeData.source = node.source;
					nodeData.element = node.type.element;

					var children = node.children;
					if (children.length === 0) {
						nodeData.name = nodeData.source;
					} else {
						nodeData.name = nodeData.element;
					}
					nodes.push({data: nodeData});

					// Edges ---------------------------------------------------
					// Connection between this node and its children

					for (var i = children.length - 1; i >= 0; i--) {
						var child = children[i];
						var childId = child.getPosition();
						edges.push({data: {id: nodeId + '-' + childId, source: nodeId, target: childId}});
					}

				});

				return {
					nodes: nodes,
					edges: edges
				}
			}
		}
	}
});



exports.Mode = Mode;
