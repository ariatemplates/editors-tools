Parser for Aria Templates.

# File system layout

* `README.md`: this current file
* `.gitignore`: Git related file
* `grammar.pegjs`: grammar of the parser
* `index.js`: entry point of the parser
* `test.tpl`: aimed at being a comprehensive input to test the parser
* `test.js`: file launching a standard test for PEG.js generated parsers, using the test data inside this module

# Versioning

To ignore:

* `grammar.js`: file generated from the `grammar.pegjs` file

Optional: any convenient script to automate the commands described in the `contribute` section below.

To version: _everything else_.

# Contribute

## Setup

To be able to use the parser, build the grammar with the following command: `call pegjs --track-line-and-column grammar.pegjs`.

## Try

To try it, you can launch the test set with the following command __after ensuring you built the grammar before__: `node test`.

## FIXME

### Completeness

Everything that is left not parsed in statement parameters can contain Aria Templates elements, which thus would not be handled. For instance:

* comments
* escaped characters like braces

These elements should be stripped off when applying another parser on it, however, their position and existence is important for edition purposes.

The ideal would be to do like with free text: free text can be broken with any AT statement, comment.

Statement parameters parsing should then follow the same pattern, like _eating everything until I encounter the beginning of something that can occur_ (here comments and escaped braces), or the end of the tag. However, mixing this with the hack made to handle brace pairs could be hard.

### Whitespaces in elements

> Is it always relevant to tell there can be some spaces between elements?

I mean, these spaces could be part of the element itself: think for instance of free text immediately following an opening tag, but think also that sometimes in some languages you consider this prepended spaces as an initial indent, for output formatting purposes. In this case, add the comment as an alternative element, and just consider whitespaces as free text.


## Backlog

1. Complete TODOs and FIXMEs from the code
1. Parse HTML parts and param statements
1. Really parse the content of the expression: `expr(|arg(:value)?)*`
	* Handle escaped pipes
1. Clean the grammar code
1. Use a graphical representation for the model: [Graphviz](http://www.graphviz.org/) or whatever

### Tokens and special characters

> Should everything be wrapped in nodes?

For instance, special characters determining the type of a node among other things, would they be part of the children of this node?

Having a single and comprehensive model for everything seems a good thing, and considering special characters as nodes (as we already do for whitespaces) would help simplifying the processings and so on.

# Documentation

## Model of a template

### Syntactic

* A template is a set of elements
* An element is either a statement or something else (this "something else" can be anything that doesn't look like a statement)
* A statement can be an inline statement or a block statement
* The single tag of the inline statement and the opening tag of a block statement have:
	* An id: the name of the statement
	* A possible parameter, which is "anything until the tag is closed"
* The closing tag of a block statement only has an id
* A block statement has a list of elements

In this model, there are two components left "fuzzy":

* The parameter of a statement: it's often pure JavaScript, like JSON objects for widgets, for loops parameters, pure expression for variable declaration, but sometimes it's a custom syntax, like for [foreach loops](http://ariatemplates.com/usermanual/Writing_Templates#foreach)
* Everything else that is not a statement: depending on the kind of template, it will be either HTML, CSS or free text, that would need to be parsed _externally_ depending on the needs.

### Semantic

Here are some important general rules:

* a whole template is contained in a unique file
* every template has a unique root statement
* a template is a set of hierarchically structured statements between which there can be any text. It's a complete mixing of it, agnostic of what the text is. Think about XML, it's the same kind of things (however JSON is not for instance).
* template statements delegates to JavaScript statements as much as possible (to express loops, object literals, ...)

However we still want to treat the free text as a specific language, depending on the type of the template for instance (HTML, CSS, ...), but in a decoupled manner.

For this the principle is to combine the use of different parsers, to apply in specific order.
